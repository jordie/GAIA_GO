<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Basic Edu Apps - Live Task Monitor</title>

    <!-- iOS-specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Task Monitor">
    <meta name="format-detection" content="telephone=no">

    <!-- Theme color for browser chrome -->
    <meta name="theme-color" content="#667eea">

    <!-- Disable iOS call/email auto-detection -->
    <meta name="format-detection" content="telephone=no, email=no">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overscroll-behavior: none;
            position: relative;
            min-height: 100vh;
        }

        /* iOS Safe Area Support */
        @supports (padding-top: env(safe-area-inset-top)) {
            body {
                padding-top: calc(20px + env(safe-area-inset-top));
                padding-left: calc(20px + env(safe-area-inset-left));
                padding-right: calc(20px + env(safe-area-inset-right));
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
            }
        }

        /* Error Banner */
        .error-banner {
            background: #ef4444;
            color: white;
            padding: 12px;
            text-align: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            animation: slideDown 0.3s;
        }
        .success-banner {
            background: #10b981;
            color: white;
            padding: 12px;
            text-align: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            animation: slideDown 0.3s;
        }
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
        }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .header p { opacity: 0.9; font-size: 14px; margin-bottom: 15px; }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .controls button, .controls select {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
            min-height: 44px;
        }
        .controls button:hover, .controls select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .controls button:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.3);
        }
        .controls select {
            background-image: url('data:image/svg+xml;utf8,<svg fill="white" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 20px;
            padding-right: 35px;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        .controls input[type="checkbox"] {
            cursor: pointer;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: #1e293b;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            transition: transform 0.2s;
        }
        .stat-card:hover {
            transform: translateY(-2px);
        }
        .stat-card h3 { font-size: 14px; color: #94a3b8; margin-bottom: 8px; }
        .stat-card .value {
            font-size: 32px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .stat-card.updated .value {
            animation: pulse 0.5s;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); color: #3b82f6; }
        }

        .tasks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        .task-card {
            background: #1e293b;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #334155;
            transition: all 0.3s;
            cursor: pointer;
        }
        .task-card:hover {
            border-color: #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        .task-card.updated {
            animation: highlight 0.5s;
        }
        @keyframes highlight {
            0%, 100% { border-color: #334155; }
            50% { border-color: #3b82f6; box-shadow: 0 0 20px rgba(59, 130, 246, 0.5); }
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .task-id {
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        .task-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .status-working { background: #10b981; color: white; }
        .status-idle { background: #3b82f6; color: white; }
        .status-error { background: #ef4444; color: white; }
        .status-completed { background: #6b7280; color: white; }
        .status-pending { background: #f59e0b; color: white; }

        .task-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #f1f5f9;
        }
        .task-session {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 10px;
        }
        .task-session strong { color: #3b82f6; }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #334155;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.5s ease;
            position: relative;
        }
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .task-step {
            font-size: 13px;
            color: #cbd5e1;
            font-style: italic;
            margin-top: 10px;
            padding: 10px;
            background: #0f172a;
            border-radius: 4px;
        }

        .refresh-info {
            text-align: center;
            margin-top: 30px;
            color: #64748b;
            font-size: 12px;
        }
        .refresh-info .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            animation: blink 2s infinite;
        }
        .status-dot.connected { background: #10b981; }
        .status-dot.disconnected { background: #ef4444; }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 8px;
        }
        .type-codex { background: #7c3aed; color: white; }
        .type-claude { background: #059669; color: white; }
        .type-comet { background: #dc2626; color: white; }

        .loading {
            text-align: center;
            padding: 40px;
            color: #94a3b8;
        }
        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Pull-to-refresh indicator */
        .pull-to-refresh {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-60px);
            transition: transform 0.3s;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 999;
            backdrop-filter: blur(10px);
        }
        .pull-to-refresh.visible {
            transform: translateX(-50%) translateY(20px);
        }

        /* Improved scrolling for iOS */
        .tasks-grid {
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        /* Prevent iOS zoom on select */
        select:focus, button:focus {
            font-size: 16px !important;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                padding-bottom: calc(10px + env(safe-area-inset-bottom, 20px));
            }
            .header h1 { font-size: 20px; }
            .header p { font-size: 12px; }
            .tasks-grid {
                grid-template-columns: 1fr;
                gap: 15px;
                padding-bottom: 20px;
            }
            .stat-card .value { font-size: 24px; }
            .controls {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            .controls button, .controls select, .controls label {
                width: 100%;
                justify-content: center;
                min-height: 48px;
                font-size: 16px;
            }
            .refresh-info {
                padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            }
        }

        @media (max-width: 480px) {
            .stats {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .stat-card {
                padding: 15px;
            }
            .stat-card .value { font-size: 20px; }
            .task-card {
                padding: 15px;
            }
            .header {
                padding: 15px;
                margin-bottom: 20px;
            }
        }

        /* iOS Dark mode status bar */
        @media (prefers-color-scheme: dark) {
            body {
                background: #0f172a;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Basic Edu Apps - Live Task Monitor</h1>
        <p id="connection-status">Connecting...</p>

        <div class="controls">
            <button id="refresh-btn" onclick="loadTasks()">&#8634; Refresh Now</button>
            <label>
                <input type="checkbox" id="auto-refresh" checked onchange="toggleAutoRefresh()">
                Auto-refresh (10s)
            </label>
            <select id="filter-status" onchange="filterTasks()">
                <option value="all">All Tasks</option>
                <option value="pending">Pending</option>
                <option value="working">In Progress</option>
                <option value="completed">Completed</option>
                <option value="error">Error</option>
            </select>
            <button onclick="clearCompleted()">&#10005; Clear Completed</button>
        </div>
    </div>

    <div class="stats">
        <div class="stat-card">
            <h3>Total Tasks</h3>
            <div class="value" id="total-tasks">-</div>
        </div>
        <div class="stat-card">
            <h3>In Progress</h3>
            <div class="value" id="in-progress">-</div>
        </div>
        <div class="stat-card">
            <h3>Completed</h3>
            <div class="value" id="completed">-</div>
        </div>
        <div class="stat-card">
            <h3>Pending</h3>
            <div class="value" id="pending">-</div>
        </div>
    </div>

    <div class="tasks-grid" id="tasks-grid">
        <div class="loading">Loading tasks</div>
    </div>

    <div class="refresh-info">
        <span class="status-dot" id="status-dot"></span>
        <span id="connection-text">Disconnected</span> â€¢
        Last updated: <span id="last-update">Never</span>
    </div>

    <script>
        let autoRefreshEnabled = true;
        let autoRefreshInterval = null;
        let allTasks = [];
        let currentFilter = 'all';
        let wsConnection = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadTasks();
            setupAutoRefresh();
            setupWebSocket();
        });

        // WebSocket Setup
        function setupWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.hostname}:8080/ws/tasks`;
                wsConnection = new WebSocket(wsUrl);

                wsConnection.onopen = () => {
                    console.log('WebSocket connected');
                    updateConnectionStatus(true);
                    reconnectAttempts = 0;
                };

                wsConnection.onmessage = (event) => {
                    try {
                        const update = JSON.parse(event.data);
                        handleTaskUpdate(update);
                    } catch (e) {
                        console.error('Failed to parse WebSocket message:', e);
                    }
                };

                wsConnection.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus(false);
                };

                wsConnection.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateConnectionStatus(false);

                    // Attempt to reconnect
                    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        setTimeout(() => {
                            console.log(`Reconnecting... Attempt ${reconnectAttempts}`);
                            setupWebSocket();
                        }, 5000 * reconnectAttempts); // Exponential backoff
                    }
                };
            } catch (e) {
                console.log('WebSocket not available, using polling');
                updateConnectionStatus(false);
            }
        }

        function updateConnectionStatus(connected) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('connection-text');
            const connectionStatus = document.getElementById('connection-status');

            if (connected) {
                statusDot.className = 'status-dot connected';
                statusText.textContent = 'Live Updates Active';
                connectionStatus.textContent = 'Real-time monitoring active';
            } else {
                statusDot.className = 'status-dot disconnected';
                statusText.textContent = 'Polling Mode';
                connectionStatus.textContent = 'Auto-refresh every 10 seconds';
            }
        }

        function handleTaskUpdate(update) {
            const taskIndex = allTasks.findIndex(t => t.id === update.id);
            if (taskIndex !== -1) {
                allTasks[taskIndex] = { ...allTasks[taskIndex], ...update };
                const card = document.querySelector(`[data-task-id="${update.id}"]`);
                if (card) {
                    card.classList.add('updated');
                    setTimeout(() => card.classList.remove('updated'), 500);
                }
            }
            renderFilteredTasks();
            updateStats(allTasks);
        }

        // Load Tasks from API
        async function loadTasks() {
            const refreshBtn = document.getElementById('refresh-btn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'Loading...';

            try {
                // Fetch from dashboard API on port 8080
                // Use explicit IP to avoid hostname resolution issues
                const apiUrl = 'http://100.112.58.92:8080/api/tasks/monitor';
                console.log('Fetching from:', apiUrl);

                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    mode: 'cors'
                });

                console.log('Response status:', response.status, response.statusText);

                if (response.ok) {
                    allTasks = await response.json();
                    console.log('Tasks loaded:', allTasks.length, 'tasks');
                    showBanner(`Loaded ${allTasks.length} tasks from API`, 'success');
                } else {
                    // Fallback to static data
                    console.error('API returned error:', response.status, response.statusText);
                    allTasks = getStaticTasks();
                    showBanner(`API error ${response.status} - Using offline data`, 'error');
                }

                renderFilteredTasks();
                updateStats(allTasks);
                updateLastUpdate();

            } catch (error) {
                console.error('Fetch error:', error.name, error.message);
                console.error('Full error:', error);
                // Use static data as fallback
                allTasks = getStaticTasks();
                renderFilteredTasks();
                updateStats(allTasks);
                showBanner(`Network error: ${error.message} - Using offline data`, 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = '\u21BB Refresh Now';
            }
        }

        function getStaticTasks() {
            return [
                {id: 1, desc: "Fix template rendering", session: "codex", type: "codex", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 2, desc: "Align database schemas", session: "codex_edu", type: "codex", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 3, desc: "Fix blueprint routing", session: "codex", type: "codex", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 4, desc: "Anchor database paths", session: "concurrent_worker1", type: "claude", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 5, desc: "Fix math sessions", session: "concurrent_worker2", type: "claude", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 6, desc: "Debug save_session errors", session: "claude", type: "claude", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 7, desc: "Environment variables", session: "claude", type: "claude", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 8, desc: "Centralize secrets", session: "claude", type: "claude", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 9, desc: "Dashboard styling", session: "comet", type: "comet", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 10, desc: "User profile view", session: "concurrent_worker3", type: "comet", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 11, desc: "Word tracking", session: "codex", type: "codex", status: "completed", progress: 100, step: "Completed successfully"},
                {id: 12, desc: "Adaptive practice", session: "codex", type: "codex", status: "completed", progress: 100, step: "Completed successfully"}
            ];
        }

        function renderFilteredTasks() {
            const filtered = currentFilter === 'all'
                ? allTasks
                : allTasks.filter(t => t.status === currentFilter);
            renderTasks(filtered);
        }

        function renderTasks(tasks) {
            const grid = document.getElementById('tasks-grid');

            if (tasks.length === 0) {
                grid.innerHTML = '<div class="loading">No tasks found</div>';
                return;
            }

            grid.innerHTML = tasks.map(task => `
                <div class="task-card" data-task-id="${task.id}">
                    <div class="task-header">
                        <span class="task-id">Task #${task.id}</span>
                        <span class="task-status status-${task.status}">${task.status}</span>
                    </div>
                    <div class="task-title">${task.desc}</div>
                    <div class="task-session">
                        Session: <strong>${task.session}</strong>
                        <span class="type-badge type-${task.type}">${task.type.toUpperCase()}</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${task.progress}%"></div>
                    </div>
                    <div class="task-step">${task.step}</div>
                </div>
            `).join('');
        }

        function updateStats(tasks) {
            const stats = {
                total: tasks.length,
                working: tasks.filter(t => t.status === 'working').length,
                completed: tasks.filter(t => t.status === 'completed').length,
                pending: tasks.filter(t => t.status === 'pending').length
            };

            animateStatUpdate('total-tasks', stats.total);
            animateStatUpdate('in-progress', stats.working);
            animateStatUpdate('completed', stats.completed);
            animateStatUpdate('pending', stats.pending);
        }

        function animateStatUpdate(elementId, newValue) {
            const element = document.getElementById(elementId);
            const oldValue = element.textContent;
            if (oldValue !== String(newValue)) {
                element.parentElement.classList.add('updated');
                element.textContent = newValue;
                setTimeout(() => {
                    element.parentElement.classList.remove('updated');
                }, 500);
            }
        }

        function updateLastUpdate() {
            document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
        }

        function filterTasks() {
            const select = document.getElementById('filter-status');
            currentFilter = select.value;
            renderFilteredTasks();
        }

        function clearCompleted() {
            allTasks = allTasks.filter(t => t.status !== 'completed');
            renderFilteredTasks();
            updateStats(allTasks);
            showBanner('Completed tasks cleared', 'success');
        }

        function setupAutoRefresh() {
            if (autoRefreshEnabled) {
                autoRefreshInterval = setInterval(() => {
                    if (autoRefreshEnabled) {
                        loadTasks();
                    }
                }, 10000);
            }
        }

        function toggleAutoRefresh() {
            autoRefreshEnabled = document.getElementById('auto-refresh').checked;
            if (autoRefreshEnabled) {
                setupAutoRefresh();
                showBanner('Auto-refresh enabled', 'success');
            } else {
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
                showBanner('Auto-refresh disabled', 'success');
            }
        }

        function showBanner(message, type = 'error') {
            const banner = document.createElement('div');
            banner.className = type === 'success' ? 'success-banner' : 'error-banner';
            banner.textContent = message;
            document.body.insertBefore(banner, document.body.firstChild);

            setTimeout(() => {
                banner.style.animation = 'slideDown 0.3s reverse';
                setTimeout(() => banner.remove(), 300);
            }, 3000);
        }

        // iOS Pull-to-Refresh
        let pullStartY = 0;
        let pullMoveY = 0;
        let isPulling = false;
        let pullIndicator = null;

        function initPullToRefresh() {
            // Create pull indicator
            pullIndicator = document.createElement('div');
            pullIndicator.className = 'pull-to-refresh';
            pullIndicator.textContent = 'Pull to refresh...';
            document.body.appendChild(pullIndicator);

            // Touch events for pull-to-refresh
            document.addEventListener('touchstart', (e) => {
                if (window.scrollY === 0) {
                    pullStartY = e.touches[0].clientY;
                    isPulling = true;
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isPulling) return;

                pullMoveY = e.touches[0].clientY;
                const pullDistance = pullMoveY - pullStartY;

                if (pullDistance > 0 && pullDistance < 150) {
                    pullIndicator.textContent = 'Pull to refresh...';
                    if (pullDistance > 50) {
                        pullIndicator.classList.add('visible');
                    }
                } else if (pullDistance >= 150) {
                    pullIndicator.textContent = 'Release to refresh';
                }
            }, { passive: true });

            document.addEventListener('touchend', (e) => {
                if (!isPulling) return;

                const pullDistance = pullMoveY - pullStartY;

                if (pullDistance >= 150) {
                    pullIndicator.textContent = 'Refreshing...';
                    loadTasks().then(() => {
                        setTimeout(() => {
                            pullIndicator.classList.remove('visible');
                            pullIndicator.textContent = 'Pull to refresh...';
                        }, 500);
                    });
                } else {
                    pullIndicator.classList.remove('visible');
                }

                isPulling = false;
                pullStartY = 0;
                pullMoveY = 0;
            }, { passive: true });
        }

        // iOS-specific enhancements
        function setupIOSEnhancements() {
            const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);

            if (isIOS) {
                // Initialize pull-to-refresh
                initPullToRefresh();

                // Prevent bounce scrolling on body
                document.body.addEventListener('touchmove', (e) => {
                    if (e.target === document.body) {
                        e.preventDefault();
                    }
                }, { passive: false });

                // Add haptic feedback on button press (vibration)
                document.querySelectorAll('button').forEach(button => {
                    button.addEventListener('touchstart', () => {
                        if (navigator.vibrate) {
                            navigator.vibrate(10);
                        }
                    }, { passive: true });
                });

                // Prevent iOS double-tap zoom on buttons
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);

                // Handle iOS keyboard appearance
                window.addEventListener('resize', () => {
                    // Scroll to keep focused element visible when keyboard appears
                    if (document.activeElement.tagName === 'SELECT') {
                        document.activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });

                console.log('iOS enhancements enabled');
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (wsConnection) {
                wsConnection.close();
            }
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
        });

        // Initialize iOS features after DOM load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupIOSEnhancements);
        } else {
            setupIOSEnhancements();
        }
    </script>
</body>
</html>
