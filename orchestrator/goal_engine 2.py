#!/usr/bin/env python3
"""
Goal-Oriented Autonomous Task Engine

Reads strategic vision from database, analyzes current state (projects, features, revenue),
auto-generates tactical tasks to advance vision, and learns from execution patterns.

Features:
- Database-driven strategic vision and goals
- Revenue tracking and analysis
- Dependency-aware task prioritization
- Pattern learning from task outcomes
- Session routing based on task type and history
- Strategic alignment scoring

Usage:
    python3 goal_engine.py --generate           # Generate and queue tasks
    python3 goal_engine.py --dry-run            # Preview tasks without queuing
    python3 goal_engine.py --show-vision        # Show strategic vision
    python3 goal_engine.py --show-state         # Show current state analysis
    python3 goal_engine.py --learn              # Analyze task outcomes and update patterns
"""

import json
import logging
import os
import re
import sqlite3
import sys
from dataclasses import asdict, dataclass
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Add parent directory to path for imports
ORCHESTRATOR_DIR = Path(__file__).parent
BASE_DIR = ORCHESTRATOR_DIR.parent
sys.path.insert(0, str(BASE_DIR))

from db import get_connection

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("GoalEngine")


class TaskCategory(str, Enum):
    """Task category enumeration."""

    REVENUE = "revenue"
    CRITICAL = "critical"
    BLOCKER = "blocker"
    STRATEGIC = "strategic"
    AUTOMATION = "automation"
    QUALITY = "quality"
    TECH_DEBT = "tech_debt"
    ENHANCEMENT = "enhancement"
    DEPENDENCY = "dependency"


@dataclass
class TaskPattern:
    """Learned pattern from task execution history."""

    category: str
    session_name: str
    success_rate: float
    avg_completion_time: float  # minutes
    last_updated: str
    sample_size: int


@dataclass
class GeneratedTask:
    """A task generated by the goal engine."""

    content: str
    priority: int
    category: str
    project: str
    reasoning: str
    dependencies: List[int] = None  # IDs of tasks that must complete first
    estimated_revenue_impact: float = 0.0
    strategic_alignment_score: float = 0.0
    preferred_session: str = None

    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "content": self.content,
            "priority": self.priority,
            "category": self.category,
            "project": self.project,
            "reasoning": self.reasoning,
            "dependencies": self.dependencies or [],
            "estimated_revenue_impact": self.estimated_revenue_impact,
            "strategic_alignment_score": self.strategic_alignment_score,
            "preferred_session": self.preferred_session,
        }


class GoalEngine:
    """
    Generates and prioritizes tasks based on strategic vision.

    The engine:
    1. Reads strategic vision from database
    2. Analyzes current project state and revenue metrics
    3. Generates tactical tasks to advance strategic goals
    4. Prioritizes tasks by revenue potential, strategic alignment, and dependencies
    5. Routes tasks to appropriate sessions based on learned patterns
    6. Tracks outcomes and learns from execution history
    """

    def __init__(self):
        self.base_path = Path(__file__).parent.parent
        self.db_path = self.base_path / "data" / "architect.db"
        self.assigner_db_path = self.base_path / "data" / "assigner" / "assigner.db"

        # Strategic priorities (configurable via database)
        self.priorities = {
            TaskCategory.REVENUE: 10,  # Revenue-generating tasks (highest)
            TaskCategory.CRITICAL: 9,  # Critical bugs/blockers
            TaskCategory.BLOCKER: 9,  # Blocking tasks
            TaskCategory.STRATEGIC: 8,  # Advances strategic goals
            TaskCategory.AUTOMATION: 7,  # Improves automation
            TaskCategory.QUALITY: 6,  # Improves quality/tests
            TaskCategory.TECH_DEBT: 5,  # Reduces technical debt
            TaskCategory.ENHANCEMENT: 4,  # Nice-to-have features
            TaskCategory.DEPENDENCY: 3,  # Dependency tasks
        }

        # Initialize database schema for vision and patterns
        self._init_goal_engine_tables()

    def _init_goal_engine_tables(self):
        """Initialize database tables for vision and pattern tracking."""
        with get_connection() as conn:
            conn.executescript(
                """
                -- Strategic vision and goals
                CREATE TABLE IF NOT EXISTS strategic_vision (
                    id INTEGER PRIMARY KEY,
                    statement TEXT NOT NULL,
                    primary_goal TEXT,
                    focus_areas TEXT,  -- JSON array
                    revenue_targets TEXT,  -- JSON object with targets
                    success_metrics TEXT,  -- JSON object
                    active INTEGER DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );

                -- Revenue tracking
                CREATE TABLE IF NOT EXISTS revenue_tracking (
                    id INTEGER PRIMARY KEY,
                    project_id INTEGER,
                    period_start DATE NOT NULL,
                    period_end DATE NOT NULL,
                    actual_revenue REAL DEFAULT 0,
                    projected_revenue REAL DEFAULT 0,
                    subscriptions INTEGER DEFAULT 0,
                    churn_rate REAL DEFAULT 0,
                    notes TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (project_id) REFERENCES projects(id)
                );

                -- Task execution patterns (for learning)
                CREATE TABLE IF NOT EXISTS task_patterns (
                    id INTEGER PRIMARY KEY,
                    category TEXT NOT NULL,
                    session_name TEXT NOT NULL,
                    success_count INTEGER DEFAULT 0,
                    failure_count INTEGER DEFAULT 0,
                    total_completion_time REAL DEFAULT 0,  -- minutes
                    last_success TIMESTAMP,
                    last_failure TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(category, session_name)
                );

                -- Task dependencies
                CREATE TABLE IF NOT EXISTS task_dependencies (
                    id INTEGER PRIMARY KEY,
                    task_id INTEGER NOT NULL,
                    depends_on_task_id INTEGER NOT NULL,
                    dependency_type TEXT DEFAULT 'blocks',  -- 'blocks', 'prerequisite'
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (task_id) REFERENCES prompts(id),
                    FOREIGN KEY (depends_on_task_id) REFERENCES prompts(id)
                );

                -- Create indexes
                CREATE INDEX IF NOT EXISTS idx_task_patterns_category ON task_patterns(category);
                CREATE INDEX IF NOT EXISTS idx_task_patterns_session ON task_patterns(session_name);
                CREATE INDEX IF NOT EXISTS idx_revenue_tracking_period ON revenue_tracking(period_start, period_end);
            """
            )

    def get_db_connection(self, db_path=None):
        """Get database connection (legacy method, prefer get_connection())."""
        path = db_path or self.db_path
        conn = sqlite3.connect(str(path))
        conn.row_factory = sqlite3.Row
        return conn

    def get_strategic_vision(self) -> Dict:
        """
        Get current strategic vision and goals from database.
        Falls back to default vision if none exists.
        """
        with get_connection() as conn:
            row = conn.execute(
                """
                SELECT * FROM strategic_vision
                WHERE active = 1
                ORDER BY created_at DESC
                LIMIT 1
            """
            ).fetchone()

            if row:
                vision = dict(row)
                # Parse JSON fields
                for field in ["focus_areas", "revenue_targets", "success_metrics"]:
                    if vision.get(field):
                        try:
                            vision[field] = json.loads(vision[field])
                        except (json.JSONDecodeError, TypeError):
                            vision[field] = {}
                return vision

        # Default vision if none in database
        default_vision = {
            "statement": "Build autonomous development capacity to create revenue streams through useful applications",
            "primary_goal": "Launch Basic EDU Apps with payment integration",
            "revenue_targets": {"month_3": 999, "month_6": 1498, "month_12": 1896, "year_1": 5000},
            "focus_areas": [
                "payment_integration",
                "automation",
                "self_healing",
                "intelligent_routing",
                "revenue_optimization",
            ],
            "success_metrics": {
                "active_subscriptions": 50,
                "monthly_recurring_revenue": 999,
                "customer_satisfaction": 4.5,
                "system_uptime": 99.5,
            },
        }

        # Store default vision in database
        self._store_vision(default_vision)
        return default_vision

    def _store_vision(self, vision: Dict) -> int:
        """Store strategic vision in database."""
        with get_connection() as conn:
            cursor = conn.execute(
                """
                INSERT INTO strategic_vision (statement, primary_goal, focus_areas, revenue_targets, success_metrics)
                VALUES (?, ?, ?, ?, ?)
            """,
                (
                    vision.get("statement"),
                    vision.get("primary_goal"),
                    json.dumps(vision.get("focus_areas", [])),
                    json.dumps(vision.get("revenue_targets", {})),
                    json.dumps(vision.get("success_metrics", {})),
                ),
            )
            return cursor.lastrowid

    def update_vision(self, **updates) -> bool:
        """Update the active strategic vision."""
        with get_connection() as conn:
            # Get current vision
            row = conn.execute(
                """
                SELECT * FROM strategic_vision WHERE active = 1
                ORDER BY created_at DESC LIMIT 1
            """
            ).fetchone()

            if not row:
                logger.warning("No active vision to update")
                return False

            # Build update query
            update_fields = []
            params = []

            for field in ["statement", "primary_goal"]:
                if field in updates:
                    update_fields.append(f"{field} = ?")
                    params.append(updates[field])

            for field in ["focus_areas", "revenue_targets", "success_metrics"]:
                if field in updates:
                    update_fields.append(f"{field} = ?")
                    params.append(json.dumps(updates[field]))

            if not update_fields:
                return False

            update_fields.append("updated_at = CURRENT_TIMESTAMP")
            params.append(row["id"])

            conn.execute(
                f"""
                UPDATE strategic_vision
                SET {', '.join(update_fields)}
                WHERE id = ?
            """,
                params,
            )

            return True

    def analyze_revenue_metrics(self) -> Dict:
        """Analyze revenue performance and trends."""
        with get_connection() as conn:
            # Get latest revenue data
            latest_revenue = conn.execute(
                """
                SELECT
                    p.name as project_name,
                    r.actual_revenue,
                    r.projected_revenue,
                    r.subscriptions,
                    r.churn_rate,
                    r.period_start,
                    r.period_end
                FROM revenue_tracking r
                LEFT JOIN projects p ON r.project_id = p.id
                WHERE r.period_end >= date('now', '-90 days')
                ORDER BY r.period_end DESC
            """
            ).fetchall()

            # Get vision revenue targets
            vision = self.get_strategic_vision()
            revenue_targets = vision.get("revenue_targets", {})

            # Calculate current month target
            months_since_start = 3  # This should be calculated from project start date
            current_target_key = f"month_{months_since_start}"
            current_target = revenue_targets.get(current_target_key, 0)

            # Sum current month revenue
            current_month_revenue = sum(
                r["actual_revenue"]
                for r in latest_revenue
                if r["period_end"] >= datetime.now().replace(day=1).strftime("%Y-%m-%d")
            )

            return {
                "current_revenue": current_month_revenue,
                "target_revenue": current_target,
                "revenue_gap": current_target - current_month_revenue,
                "on_track": current_month_revenue >= (current_target * 0.8),  # 80% threshold
                "latest_data": [dict(r) for r in latest_revenue],
                "total_subscriptions": sum(r["subscriptions"] or 0 for r in latest_revenue),
                "avg_churn_rate": sum(r["churn_rate"] or 0 for r in latest_revenue)
                / max(len(latest_revenue), 1),
            }

    def analyze_current_state(self) -> Dict:
        """
        Analyze current project state, including features, bugs, and revenue.
        Enhanced with revenue metrics and dependency tracking.
        """
        with get_connection() as conn:
            state = {
                "projects": {},
                "blockers": [],
                "opportunities": [],
                "revenue": self.analyze_revenue_metrics(),
            }

            # Get active projects with enhanced metrics
            projects = conn.execute(
                """
                SELECT id, name, status, priority, description, source_path
                FROM projects
                WHERE status = 'active'
                ORDER BY priority DESC
            """
            ).fetchall()

            for row in projects:
                project_id = row["id"]
                project_name = row["name"]

                # Get project features with status breakdown
                feature_stats = conn.execute(
                    """
                    SELECT
                        COUNT(*) as total,
                        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
                        SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
                        SUM(CASE WHEN status = 'draft' THEN 1 ELSE 0 END) as draft,
                        SUM(CASE WHEN status = 'blocked' THEN 1 ELSE 0 END) as blocked,
                        SUM(estimated_hours) as total_estimated_hours,
                        SUM(actual_hours) as total_actual_hours
                    FROM features
                    WHERE project_id = ?
                """,
                    (project_id,),
                ).fetchone()

                # Get blocking bugs
                blocker_count = conn.execute(
                    """
                    SELECT COUNT(*) as count
                    FROM bugs
                    WHERE project_id = ? AND severity = 'critical' AND status != 'resolved'
                """,
                    (project_id,),
                ).fetchone()["count"]

                # Calculate completion percentage
                total_features = feature_stats["total"] or 0
                completed_features = feature_stats["completed"] or 0
                completion_pct = (
                    (completed_features / total_features * 100) if total_features > 0 else 0
                )

                # Identify if project is revenue-generating
                is_revenue_project = (
                    "edu" in project_name.lower() or "payment" in project_name.lower()
                )

                state["projects"][project_name] = {
                    "id": project_id,
                    "priority": row["priority"],
                    "features_total": total_features,
                    "features_completed": completed_features,
                    "features_in_progress": feature_stats["in_progress"] or 0,
                    "features_draft": feature_stats["draft"] or 0,
                    "features_blocked": feature_stats["blocked"] or 0,
                    "blockers": blocker_count,
                    "completion_percentage": round(completion_pct, 1),
                    "is_revenue_project": is_revenue_project,
                    "estimated_hours": feature_stats["total_estimated_hours"] or 0,
                    "actual_hours": feature_stats["total_actual_hours"] or 0,
                }

                # Track blockers
                if blocker_count > 0:
                    state["blockers"].append(
                        {
                            "project": project_name,
                            "count": blocker_count,
                            "priority": row["priority"],
                        }
                    )

                # Track near-completion opportunities
                if 75 <= completion_pct < 100 and total_features > 0:
                    state["opportunities"].append(
                        {
                            "type": "near_completion",
                            "project": project_name,
                            "completion": completion_pct,
                            "remaining_features": total_features - completed_features,
                            "is_revenue": is_revenue_project,
                        }
                    )

            return state

    def learn_from_patterns(self) -> Dict:
        """
        Analyze task execution history and update pattern database.
        This helps route future tasks to sessions with proven success rates.
        """
        logger.info("Analyzing task execution patterns...")

        with self.get_db_connection(self.assigner_db_path) as conn:
            # Get completed tasks from last 30 days
            cutoff = (datetime.now() - timedelta(days=30)).isoformat()

            completed_tasks = conn.execute(
                """
                SELECT
                    id,
                    content,
                    assigned_session,
                    status,
                    metadata,
                    created_at,
                    assigned_at,
                    completed_at
                FROM prompts
                WHERE completed_at > ?
                    AND assigned_session IS NOT NULL
                    AND status IN ('completed', 'failed')
            """,
                (cutoff,),
            ).fetchall()

            patterns = {}
            for task in completed_tasks:
                try:
                    metadata = json.loads(task["metadata"]) if task["metadata"] else {}
                    category = metadata.get("category", "unknown")
                    session = task["assigned_session"]

                    # Calculate completion time
                    if task["assigned_at"] and task["completed_at"]:
                        assigned = datetime.fromisoformat(task["assigned_at"])
                        completed = datetime.fromisoformat(task["completed_at"])
                        completion_time = (completed - assigned).total_seconds() / 60  # minutes
                    else:
                        completion_time = 0

                    key = (category, session)
                    if key not in patterns:
                        patterns[key] = {
                            "category": category,
                            "session": session,
                            "successes": 0,
                            "failures": 0,
                            "total_time": 0,
                            "samples": [],
                        }

                    if task["status"] == "completed":
                        patterns[key]["successes"] += 1
                    else:
                        patterns[key]["failures"] += 1

                    patterns[key]["total_time"] += completion_time
                    patterns[key]["samples"].append(completion_time)

                except Exception as e:
                    logger.debug(f"Error processing task {task['id']}: {e}")
                    continue

        # Update pattern database
        updated_count = 0
        with get_connection() as conn:
            for (category, session), data in patterns.items():
                total = data["successes"] + data["failures"]
                if total == 0:
                    continue

                conn.execute(
                    """
                    INSERT INTO task_patterns (category, session_name, success_count, failure_count, total_completion_time, updated_at)
                    VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                    ON CONFLICT(category, session_name) DO UPDATE SET
                        success_count = success_count + excluded.success_count,
                        failure_count = failure_count + excluded.failure_count,
                        total_completion_time = total_completion_time + excluded.total_completion_time,
                        updated_at = CURRENT_TIMESTAMP
                """,
                    (category, session, data["successes"], data["failures"], data["total_time"]),
                )
                updated_count += 1

        logger.info(f"Updated {updated_count} task patterns")

        # Return summary
        return {
            "patterns_analyzed": len(patterns),
            "patterns_updated": updated_count,
            "tasks_processed": len(completed_tasks),
        }

    def get_best_session_for_category(self, category: str) -> Optional[str]:
        """
        Get the best session for a given task category based on historical success.
        Returns session name with highest success rate.
        """
        with get_connection() as conn:
            patterns = conn.execute(
                """
                SELECT
                    session_name,
                    success_count,
                    failure_count,
                    total_completion_time,
                    (CAST(success_count AS REAL) / (success_count + failure_count)) as success_rate,
                    (total_completion_time / success_count) as avg_time
                FROM task_patterns
                WHERE category = ?
                    AND (success_count + failure_count) >= 3  -- Minimum sample size
                ORDER BY success_rate DESC, avg_time ASC
                LIMIT 1
            """,
                (category,),
            ).fetchone()

            if patterns:
                logger.debug(
                    f"Best session for {category}: {patterns['session_name']} "
                    f"({patterns['success_rate']*100:.1f}% success rate)"
                )
                return patterns["session_name"]

            return None

    def calculate_strategic_alignment(self, task_category: str, project: str) -> float:
        """
        Calculate how well a task aligns with strategic vision.
        Returns score from 0.0 to 1.0.
        """
        vision = self.get_strategic_vision()
        focus_areas = vision.get("focus_areas", [])

        score = 0.5  # Base score

        # High alignment with focus areas
        for area in focus_areas:
            area_lower = area.lower().replace("_", " ")
            if area_lower in task_category.lower() or area_lower in project.lower():
                score += 0.1

        # Revenue-generating projects get highest alignment
        if "revenue" in task_category.lower():
            score += 0.3

        # Strategic projects
        if "strategic" in task_category.lower():
            score += 0.2

        return min(1.0, score)

    def estimate_revenue_impact(self, task_category: str, project: str) -> float:
        """
        Estimate potential revenue impact of a task.
        Returns estimated monthly revenue impact in dollars.
        """
        # Revenue-generating tasks have direct impact
        if task_category == TaskCategory.REVENUE:
            return 500.0  # Estimated monthly impact

        # Payment integration enables all revenue
        if "payment" in task_category.lower() or "stripe" in task_category.lower():
            return 1000.0

        # Subscription features
        if "subscription" in task_category.lower():
            return 800.0

        # Quality improvements prevent churn
        if task_category == TaskCategory.QUALITY and "edu" in project.lower():
            return 200.0

        # Automation saves time = opportunity cost
        if task_category == TaskCategory.AUTOMATION:
            return 100.0

        return 0.0

    def generate_tasks_from_vision(self) -> List[GeneratedTask]:
        """
        Generate tactical tasks from strategic vision.
        Enhanced with revenue impact, strategic alignment, and session routing.
        """
        vision = self.get_strategic_vision()
        state = self.analyze_current_state()
        revenue_metrics = state.get("revenue", {})

        generated_tasks = []

        # =====================================================================
        # REVENUE-FOCUSED TASKS (Highest Priority)
        # =====================================================================

        # Check if we're behind on revenue targets
        revenue_gap = revenue_metrics.get("revenue_gap", 0)
        if revenue_gap > 0 and "payment_integration" in vision.get("focus_areas", []):
            payment_session = self.get_best_session_for_category("revenue") or "dev_worker1"

            generated_tasks.extend(
                [
                    GeneratedTask(
                        content="Implement Stripe payment integration for Basic EDU subscription tiers",
                        priority=self.priorities[TaskCategory.REVENUE],
                        category=TaskCategory.REVENUE,
                        project="Basic EDU Apps",
                        reasoning=f"Critical for revenue - currently ${revenue_gap:.0f} behind target",
                        estimated_revenue_impact=1000.0,
                        strategic_alignment_score=1.0,
                        preferred_session=payment_session,
                    ),
                    GeneratedTask(
                        content="Create subscription tier pricing page with monthly/annual options ($9.99, $14.99, $19.99)",
                        priority=self.priorities[TaskCategory.REVENUE],
                        category=TaskCategory.REVENUE,
                        project="Basic EDU Apps",
                        reasoning="Required for monetization - enables revenue generation",
                        estimated_revenue_impact=800.0,
                        strategic_alignment_score=1.0,
                        preferred_session=payment_session,
                    ),
                    GeneratedTask(
                        content="Build admin dashboard for subscription management and analytics",
                        priority=self.priorities[TaskCategory.REVENUE] - 1,
                        category=TaskCategory.REVENUE,
                        project="Basic EDU Apps",
                        reasoning="Essential for business operations and customer management",
                        estimated_revenue_impact=500.0,
                        strategic_alignment_score=0.9,
                        preferred_session=payment_session,
                    ),
                ]
            )

        # =====================================================================
        # CRITICAL BLOCKERS (Immediate Action Required)
        # =====================================================================

        for blocker in state.get("blockers", []):
            blocker_session = self.get_best_session_for_category("blocker") or "dev_worker2"

            generated_tasks.append(
                GeneratedTask(
                    content=f"Resolve {blocker['count']} critical bugs blocking {blocker['project']}",
                    priority=self.priorities[TaskCategory.CRITICAL],
                    category=TaskCategory.BLOCKER,
                    project=blocker["project"],
                    reasoning="Blocking progress on high-priority project",
                    estimated_revenue_impact=300.0 if blocker.get("is_revenue") else 0.0,
                    strategic_alignment_score=0.9,
                    preferred_session=blocker_session,
                )
            )

        # =====================================================================
        # NEAR-COMPLETION OPPORTUNITIES (High ROI)
        # =====================================================================

        for opportunity in state.get("opportunities", []):
            if opportunity["type"] == "near_completion":
                project = opportunity["project"]
                completion = opportunity["completion"]
                remaining = opportunity["remaining_features"]

                completion_session = (
                    self.get_best_session_for_category("strategic") or "dev_worker1"
                )

                revenue_impact = 1500.0 if opportunity.get("is_revenue") else 200.0

                generated_tasks.append(
                    GeneratedTask(
                        content=f"Complete remaining {remaining} features to launch {project} (currently {completion:.0f}% complete)",
                        priority=self.priorities[TaskCategory.STRATEGIC],
                        category=TaskCategory.STRATEGIC,
                        project=project,
                        reasoning=f"Project is {completion:.0f}% complete - finish for launch",
                        estimated_revenue_impact=revenue_impact,
                        strategic_alignment_score=0.8,
                        preferred_session=completion_session,
                    )
                )

        # =====================================================================
        # AUTOMATION IMPROVEMENTS (Force Multipliers)
        # =====================================================================

        if "automation" in vision.get("focus_areas", []):
            automation_session = self.get_best_session_for_category("automation") or "architect"

            generated_tasks.extend(
                [
                    GeneratedTask(
                        content="Implement automated deployment pipeline for Basic EDU staging environment",
                        priority=self.priorities[TaskCategory.AUTOMATION],
                        category=TaskCategory.AUTOMATION,
                        project="DevOps",
                        reasoning="Accelerates development and reduces manual work",
                        estimated_revenue_impact=100.0,
                        strategic_alignment_score=0.7,
                        preferred_session=automation_session,
                    ),
                    GeneratedTask(
                        content="Create automated test suite for payment integration endpoints",
                        priority=self.priorities[TaskCategory.QUALITY],
                        category=TaskCategory.QUALITY,
                        project="Basic EDU Apps",
                        reasoning="Ensures payment reliability - prevents revenue loss",
                        estimated_revenue_impact=200.0,
                        strategic_alignment_score=0.8,
                        preferred_session=automation_session,
                    ),
                ]
            )

        # =====================================================================
        # SELF-HEALING INTEGRATION
        # =====================================================================

        if "self_healing" in vision.get("focus_areas", []):
            generated_tasks.append(
                GeneratedTask(
                    content="Integrate health monitor with dashboard for real-time system status",
                    priority=self.priorities[TaskCategory.AUTOMATION],
                    category=TaskCategory.AUTOMATION,
                    project="Architect Dashboard",
                    reasoning="Improves system reliability and reduces manual monitoring",
                    estimated_revenue_impact=150.0,
                    strategic_alignment_score=0.7,
                    preferred_session="architect",
                )
            )

        # =====================================================================
        # INTELLIGENT ROUTING INTEGRATION
        # =====================================================================

        if "intelligent_routing" in vision.get("focus_areas", []):
            generated_tasks.append(
                GeneratedTask(
                    content="Integrate intelligent router with assigner worker for automatic task routing",
                    priority=self.priorities[TaskCategory.AUTOMATION],
                    category=TaskCategory.AUTOMATION,
                    project="Architect Dashboard",
                    reasoning="Optimizes task assignment and improves success rates",
                    estimated_revenue_impact=100.0,
                    strategic_alignment_score=0.7,
                    preferred_session="architect",
                )
            )

        # =====================================================================
        # QUALITY IMPROVEMENTS (Revenue Protection)
        # =====================================================================

        for project_name, project_data in state.get("projects", {}).items():
            if (
                project_data.get("is_revenue_project")
                and project_data.get("completion_percentage", 0) > 50
            ):
                quality_session = self.get_best_session_for_category("quality") or "dev_worker2"

                generated_tasks.append(
                    GeneratedTask(
                        content=f"Implement comprehensive error handling and logging for {project_name}",
                        priority=self.priorities[TaskCategory.QUALITY],
                        category=TaskCategory.QUALITY,
                        project=project_name,
                        reasoning="Prevents customer churn and revenue loss",
                        estimated_revenue_impact=250.0,
                        strategic_alignment_score=0.6,
                        preferred_session=quality_session,
                    )
                )

        return generated_tasks

    def deduplicate_tasks(self, tasks: List[GeneratedTask]) -> List[GeneratedTask]:
        """Remove duplicate or similar tasks."""
        seen = set()
        unique_tasks = []

        for task in tasks:
            # Create a normalized key for deduplication
            key = task.content.lower().strip()
            key = re.sub(r"\s+", " ", key)  # Normalize whitespace

            if key not in seen:
                seen.add(key)
                unique_tasks.append(task)
            else:
                logger.debug(f"Skipping duplicate task: {task.content[:50]}...")

        return unique_tasks

    def check_existing_tasks(self, task_content: str) -> bool:
        """Check if similar task already exists in queue."""
        try:
            conn = self.get_db_connection(self.assigner_db_path)
            cursor = conn.cursor()

            # Check for similar tasks in last 7 days
            cutoff = (datetime.now() - timedelta(days=7)).isoformat()

            cursor.execute(
                """
                SELECT id, content FROM prompts
                WHERE created_at > ?
                    AND status IN ('pending', 'assigned', 'in_progress')
            """,
                (cutoff,),
            )

            for row in cursor.fetchall():
                # Simple similarity check
                existing = row["content"].lower()
                new = task_content.lower()

                # Extract key words
                existing_words = set(re.findall(r"\b\w+\b", existing))
                new_words = set(re.findall(r"\b\w+\b", new))

                # Calculate similarity (Jaccard)
                intersection = existing_words & new_words
                union = existing_words | new_words

                if len(union) > 0:
                    similarity = len(intersection) / len(union)

                    if similarity > 0.7:  # 70% similarity threshold
                        logger.info(f"Similar task already exists (ID: {row['id']})")
                        conn.close()
                        return True

            conn.close()
            return False

        except Exception as e:
            logger.error(f"Error checking existing tasks: {e}")
            return False

    def queue_task(self, task: GeneratedTask) -> Optional[int]:
        """
        Queue a generated task to the assigner worker.
        Enhanced with revenue impact, strategic alignment, and session routing.
        """
        try:
            # Check if similar task exists
            if self.check_existing_tasks(task.content):
                logger.info(f"Skipping duplicate: {task.content[:50]}...")
                return None

            conn = self.get_db_connection(self.assigner_db_path)
            cursor = conn.cursor()

            # Build comprehensive metadata
            metadata = {
                "category": task.category,
                "project": task.project,
                "reasoning": task.reasoning,
                "generated_by": "goal_engine",
                "generated_at": datetime.now().isoformat(),
                "revenue_impact": task.estimated_revenue_impact,
                "strategic_alignment": task.strategic_alignment_score,
                "dependencies": task.dependencies or [],
            }

            # Insert task into assigner queue
            cursor.execute(
                """
                INSERT INTO prompts (
                    content, priority, status, created_at, metadata, target_session
                )
                VALUES (?, ?, 'pending', ?, ?, ?)
            """,
                (
                    task.content,
                    task.priority,
                    datetime.now().isoformat(),
                    json.dumps(metadata),
                    task.preferred_session,
                ),
            )

            task_id = cursor.lastrowid
            conn.commit()
            conn.close()

            logger.info(
                f"✓ Queued task {task_id}: {task.content[:60]}... "
                f"(priority: {task.priority}, revenue: ${task.estimated_revenue_impact:.0f}, "
                f"session: {task.preferred_session or 'auto'})"
            )
            return task_id

        except Exception as e:
            logger.error(f"Failed to queue task: {e}")
            return None

    def generate_and_queue_tasks(self, dry_run=False, max_tasks=None) -> Dict:
        """
        Generate tasks from vision and queue them.

        Args:
            dry_run: If True, show tasks without queuing
            max_tasks: Maximum number of tasks to queue (default: no limit)

        Returns:
            Dict with generation statistics and task details
        """
        logger.info("=" * 60)
        logger.info("Goal-Oriented Task Engine - Generating Tasks")
        logger.info("=" * 60)

        # Generate tasks from strategic vision
        tasks = self.generate_tasks_from_vision()
        logger.info(f"Generated {len(tasks)} tasks from vision")

        # Deduplicate
        unique_tasks = self.deduplicate_tasks(tasks)
        logger.info(f"After deduplication: {len(unique_tasks)} unique tasks")

        # Sort by multiple criteria:
        # 1. Revenue impact (highest first)
        # 2. Priority (highest first)
        # 3. Strategic alignment (highest first)
        unique_tasks.sort(
            key=lambda t: (t.estimated_revenue_impact, t.priority, t.strategic_alignment_score),
            reverse=True,
        )

        # Limit tasks if requested
        if max_tasks and len(unique_tasks) > max_tasks:
            logger.info(f"Limiting to top {max_tasks} tasks")
            unique_tasks = unique_tasks[:max_tasks]

        results = {
            "generated": len(tasks),
            "unique": len(unique_tasks),
            "queued": 0,
            "skipped": 0,
            "total_revenue_impact": sum(t.estimated_revenue_impact for t in unique_tasks),
            "tasks": [],
        }

        if dry_run:
            logger.info("DRY RUN - Not queuing tasks")
            results["tasks"] = [t.to_dict() for t in unique_tasks]
            return results

        # Queue tasks
        logger.info(f"Queuing {len(unique_tasks)} tasks...")
        for task in unique_tasks:
            task_id = self.queue_task(task)
            if task_id:
                results["queued"] += 1
                task_dict = task.to_dict()
                task_dict["id"] = task_id
                results["tasks"].append(task_dict)
            else:
                results["skipped"] += 1

        logger.info("=" * 60)
        logger.info(f"✓ Queued {results['queued']} tasks, skipped {results['skipped']} duplicates")
        logger.info(
            f"✓ Total potential revenue impact: ${results['total_revenue_impact']:.2f}/month"
        )
        logger.info("=" * 60)

        return results


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Goal-Oriented Autonomous Task Engine",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate and queue tasks from strategic vision
  python3 goal_engine.py --generate

  # Preview tasks without queuing
  python3 goal_engine.py --dry-run

  # Limit number of tasks queued
  python3 goal_engine.py --generate --max-tasks 5

  # Show strategic vision
  python3 goal_engine.py --show-vision

  # Analyze current state
  python3 goal_engine.py --show-state

  # Show revenue metrics
  python3 goal_engine.py --show-revenue

  # Learn from task execution patterns
  python3 goal_engine.py --learn

  # Update vision
  python3 goal_engine.py --update-vision --field primary_goal --value "Launch EDU apps with 100 paying users"
        """,
    )

    parser.add_argument(
        "--generate", action="store_true", help="Generate and queue tasks from vision"
    )
    parser.add_argument("--dry-run", action="store_true", help="Show tasks without queuing")
    parser.add_argument("--max-tasks", type=int, help="Maximum number of tasks to queue")
    parser.add_argument("--show-vision", action="store_true", help="Show strategic vision")
    parser.add_argument("--show-state", action="store_true", help="Show current state analysis")
    parser.add_argument("--show-revenue", action="store_true", help="Show revenue metrics")
    parser.add_argument(
        "--learn",
        action="store_true",
        help="Analyze task execution patterns and update learning database",
    )
    parser.add_argument(
        "--update-vision",
        action="store_true",
        help="Update strategic vision (requires --field and --value)",
    )
    parser.add_argument("--field", type=str, help="Vision field to update")
    parser.add_argument("--value", type=str, help="New value for vision field")

    args = parser.parse_args()

    engine = GoalEngine()

    if args.show_vision:
        vision = engine.get_strategic_vision()
        print("\n" + "=" * 60)
        print("STRATEGIC VISION")
        print("=" * 60)
        print(json.dumps(vision, indent=2))
        print("=" * 60 + "\n")

    elif args.show_revenue:
        revenue = engine.analyze_revenue_metrics()
        print("\n" + "=" * 60)
        print("REVENUE METRICS")
        print("=" * 60)
        print(json.dumps(revenue, indent=2, default=str))
        print("=" * 60 + "\n")

    elif args.show_state:
        state = engine.analyze_current_state()
        print("\n" + "=" * 60)
        print("CURRENT STATE ANALYSIS")
        print("=" * 60)
        print(json.dumps(state, indent=2, default=str))
        print("=" * 60 + "\n")

    elif args.learn:
        print("\n" + "=" * 60)
        print("LEARNING FROM TASK EXECUTION PATTERNS")
        print("=" * 60)
        results = engine.learn_from_patterns()
        print(f"Tasks processed: {results['tasks_processed']}")
        print(f"Patterns analyzed: {results['patterns_analyzed']}")
        print(f"Patterns updated: {results['patterns_updated']}")
        print("=" * 60 + "\n")

    elif args.update_vision:
        if not args.field or not args.value:
            print("Error: --update-vision requires --field and --value")
            parser.print_help()
            sys.exit(1)

        try:
            value = json.loads(args.value)
        except json.JSONDecodeError:
            value = args.value

        if engine.update_vision(**{args.field: value}):
            print(f"✓ Updated vision: {args.field} = {value}")
        else:
            print(f"✗ Failed to update vision")

    elif args.generate or args.dry_run:
        results = engine.generate_and_queue_tasks(dry_run=args.dry_run, max_tasks=args.max_tasks)

        print(f"\n{'='*70}")
        print(f"TASK GENERATION SUMMARY")
        print(f"{'='*70}")
        print(f"Generated:        {results['generated']} tasks")
        print(f"Unique:           {results['unique']} tasks")
        print(f"Queued:           {results['queued']} tasks")
        print(f"Skipped:          {results['skipped']} duplicates")
        print(f"Revenue Impact:   ${results['total_revenue_impact']:.2f}/month")
        print(f"{'='*70}\n")

        if args.dry_run:
            print("TASKS (DRY RUN - NOT QUEUED):\n")
            for i, task in enumerate(results["tasks"], 1):
                print(f"{i}. [{task['priority']}] {task['content']}")
                print(f"   Category:   {task['category']}")
                print(f"   Project:    {task['project']}")
                print(f"   Revenue:    ${task['estimated_revenue_impact']:.2f}/month")
                print(f"   Alignment:  {task['strategic_alignment_score']:.1%}")
                print(f"   Session:    {task['preferred_session'] or 'auto'}")
                print(f"   Reasoning:  {task['reasoning']}")
                print()

    else:
        parser.print_help()


if __name__ == "__main__":
    main()
